# Welcome!

I would imagine that many programmers have, at some point in their career, thought about the quirks and limitations of their primary tools, the programming languages in which we express our intent to computers. I know I have! I have wondered so much, in fact, that at some point I started to ask myself what would I consider an 'ideal' programming language to look like. Once upon a time I may have thought a truly ideal language actually existed; I know better now, but at the same time I have honed in on what I would prioritize in a programming language, along with where do I see holes in the landscape of today's programming languages. 

In particular, my own interests have gravitated over the years in the direction of systems languages. Yet, at the same time, I remain influenced by the advanced levels of abstraction possible in higher-level languages such as Haskell. Historically there have been few languages able to operate in both capacities, with C++ having been the only real option for many years, but only imperfectly able to model abstraction. Only in the last few years have we seen movement in this area, Rust being the leading example of such a new language. Still, I have set my sights on something further.

In this space, I wish to record some of the ideas I have come across or even explored myself over the years. In the first section
I will be summarizing the situation today in Rust and other languages, and in the second section I will go over some of the type theory
underpinning Rust. This is to set a baseline upon which I will build. If these are familiar to you, feel free to skip
to the third section where my additions start.

[The Road of Resource Management: The situation from past to today](1.md)

[Substructural Type Systems](2.md)

[Before we go on: Some Conventions](3.md)

[Choice](4.md)

[Coroutines and Continuations](5.md)